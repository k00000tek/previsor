<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>PreVisor Dashboard</title>

  <link rel="icon" href="favicon.ico" type="image/x-icon" />

  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

  <!-- Montserrat -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700;750;800&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#000000;
      --ink:#EAF0FF;
      --muted:rgba(234,240,255,.72);

      /* Palette accents */
      --violet:#5804A4;
      --lavender:#CF9DFF;
      --indigo:#1318F3;
      --blue:#3C7DF9;

      /* Ultra-dark glass */
      --cardA: rgba(0,0,0,.18);
      --cardB: rgba(0,0,0,.12);
      --cardHeader: rgba(0,0,0,.18);

      --strokeSoft: rgba(60,125,249,.16);
      --strokeMid:  rgba(60,125,249,.26);

      --shadow: 0 18px 55px rgba(0,0,0,.90);

      --radius2: 22px;
      --radius: 18px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }

    body{
      margin:0;
      font-family: "Montserrat", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--ink);
      background: var(--bg);
      overflow-x:hidden;
      padding: 26px 0 40px;
    }

    /* Neon tubes overlay */
    .tube-overlay{
      position: fixed;
      inset: -20vh -15vw;
      pointer-events:none;
      z-index: 0;
      opacity: 1;
      mix-blend-mode: screen;
      transform: translateZ(0);
    }

    .wrap{ position: relative; z-index: 1; }

    .mono{
      font-family: "Montserrat", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-variant-numeric: tabular-nums;
      letter-spacing: .15px;
    }

    .small-muted { font-size: 0.9rem; color: var(--muted) !important; }

    /* Topbar */
    .topbar{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:16px;
      margin-bottom: 16px;
    }

    .brand{
      display:flex;
      align-items:center;
      gap:14px;
      min-width: 0;
    }

    /* LOGO */
    .logoFrame{
      width: 78px;
      height: 78px;
      border-radius: 22px;
      padding: 3px;
      background: linear-gradient(135deg,
        rgba(60,125,249,.80),
        rgba(19,24,243,.70),
        rgba(88,4,164,.55),
        rgba(207,157,255,.35)
      );
      box-shadow:
        0 14px 40px rgba(0,0,0,.92),
        0 0 26px rgba(60,125,249,.12),
        0 0 18px rgba(19,24,243,.10),
        0 0 14px rgba(88,4,164,.08);
      flex: 0 0 auto;
    }
    .logo{
      width: 100%;
      height: 100%;
      border-radius: 19px;
      object-fit: cover;
      display:block;
      background: rgba(0,0,0,.40);
      border: 1px solid rgba(255,255,255,.06);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.35);
    }

    .brand h1{
      margin:0;
      font-size: 22px;
      letter-spacing: .12px;
      font-weight: 800;
      line-height: 1.08;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: rgba(234,240,255,.98);
      text-shadow:
        0 0 12px rgba(60,125,249,.10),
        0 0 10px rgba(19,24,243,.08);
    }

    .statusline{
      margin-top: 6px;
      display:flex;
      flex-wrap: wrap;
      gap: 10px 14px;
      align-items: center;
      color: rgba(234,240,255,.74);
      font-size: 12.5px;
    }

    .kpi{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(60,125,249,.18);
      background: rgba(0,0,0,.20);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      white-space: nowrap;
      box-shadow: 0 0 16px rgba(60,125,249,.04);
    }

    .kpi .dot{
      width: 8px; height: 8px; border-radius: 99px;
      background: rgba(234,240,255,.55);
      box-shadow: 0 0 12px rgba(234,240,255,.06);
    }
    .kpi.primary .dot{ background: rgba(60,125,249,.90); box-shadow: 0 0 16px rgba(60,125,249,.14); }
    .kpi.secondary .dot{ background: rgba(19,24,243,.90); box-shadow: 0 0 16px rgba(19,24,243,.12); }
    .kpi.tertiary .dot{ background: rgba(88,4,164,.85); box-shadow: 0 0 16px rgba(88,4,164,.10); }

    /* Buttons */
    .btn-neon{
      border: 1px solid rgba(60,125,249,.55) !important;
      background: rgba(0,0,0,.22) !important;
      color: rgba(234,240,255,.95) !important;
      border-radius: 14px !important;
      padding: 10px 12px !important;
      font-weight: 800 !important;
      letter-spacing:.2px !important;
      box-shadow:
        0 18px 45px rgba(0,0,0,.76) !important,
        0 0 20px rgba(60,125,249,.10) !important,
        0 0 14px rgba(19,24,243,.08) !important;
      transition: transform .15s ease, filter .15s ease, box-shadow .15s ease;
    }
    .btn-neon:hover{
      filter: brightness(1.06);
      transform: translateY(-1px);
      box-shadow:
        0 18px 45px rgba(0,0,0,.76) !important,
        0 0 26px rgba(60,125,249,.14) !important,
        0 0 18px rgba(19,24,243,.10) !important,
        0 0 14px rgba(88,4,164,.08) !important;
    }
    .btn-neon:active{ transform: translateY(0px) scale(.99); }

    .btn-ghost{
      border: 1px solid rgba(19,24,243,.32) !important;
      background: rgba(0,0,0,.20) !important;
      color: rgba(234,240,255,.92) !important;
      border-radius: 14px !important;
      padding: 10px 12px !important;
      font-weight: 800 !important;
      letter-spacing:.2px !important;
      box-shadow:
        0 0 16px rgba(19,24,243,.05),
        0 0 12px rgba(88,4,164,.04);
      transition: transform .15s ease, filter .15s ease, box-shadow .15s ease;
    }
    .btn-ghost:hover{
      filter: brightness(1.06);
      transform: translateY(-1px);
      box-shadow:
        0 0 22px rgba(19,24,243,.08),
        0 0 16px rgba(88,4,164,.06);
    }
    .btn-ghost:active{ transform: translateY(0px) scale(.99); }

    /* Cards */
    .card{
      border-radius: var(--radius2) !important;
      border: 1px solid transparent !important;
      background:
        linear-gradient(180deg, var(--cardA), var(--cardB)) padding-box,
        linear-gradient(135deg,
          rgba(60,125,249,.40),
          rgba(19,24,243,.30),
          rgba(88,4,164,.22),
          rgba(207,157,255,.16)
        ) border-box !important;
      box-shadow:
        var(--shadow) !important,
        0 0 0 1px rgba(60,125,249,.10) !important,
        0 0 18px rgba(60,125,249,.05) !important,
        0 0 14px rgba(19,24,243,.04) !important,
        0 0 12px rgba(88,4,164,.03) !important;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      overflow: hidden;
      position: relative;
    }

    .card::after{
      content:"";
      position:absolute;
      inset: 0;
      pointer-events:none;
      border-radius: inherit;
      background: radial-gradient(800px 260px at 20% 0%, rgba(60,125,249,.05), transparent 60%);
      opacity: .55;
    }
    .card > *{ position: relative; z-index: 1; }

    .card-header{
      border-bottom: 1px solid rgba(60,125,249,.16) !important;
      background: var(--cardHeader) !important;
      color: rgba(234,240,255,.93) !important;
      font-weight: 800;
      letter-spacing: .25px;
      text-transform: uppercase;
      font-size: 13px;
      text-shadow:
        0 0 12px rgba(60,125,249,.06),
        0 0 10px rgba(19,24,243,.05);
    }

    /* Inputs */
    label.form-label{
      color: rgba(234,240,255,.84);
      font-size: 12px;
      margin-bottom: 6px;
      font-weight: 700;
      letter-spacing: .12px;
    }

    .form-control{
      color: rgba(234,240,255,.95) !important;
      background: rgba(0,0,0,.20) !important;
      border: 1px solid rgba(60,125,249,.22) !important;
      border-radius: 14px !important;
      box-shadow: 0 0 14px rgba(60,125,249,.04);
      font-family: "Montserrat", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif !important;
    }

    .form-control:focus{
      border-color: rgba(60,125,249,.55) !important;
      box-shadow:
        0 0 0 .2rem rgba(60,125,249,.08) !important,
        0 0 20px rgba(19,24,243,.10) !important;
      background: rgba(0,0,0,.22) !important;
      color: rgba(234,240,255,.98) !important;
    }

    /* Dropdown */
    .dropdown-menu{
      background: rgba(0,0,0,.78) !important;
      border: 1px solid rgba(60,125,249,.28) !important;
      border-radius: 16px !important;
      box-shadow:
        0 22px 60px rgba(0,0,0,.92) !important,
        0 0 22px rgba(60,125,249,.08) !important,
        0 0 16px rgba(88,4,164,.06) !important;
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      padding: 8px !important;
    }

    .dropdown-item{
      color: rgba(234,240,255,.92) !important;
      border-radius: 12px !important;
      padding: 10px 10px !important;
      font-weight: 650;
    }

    .dropdown-item:hover{
      background: rgba(60,125,249,.08) !important;
      color: rgba(234,240,255,.98) !important;
    }

    .mode-help {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 1px solid rgba(60,125,249,.40);
      color: rgba(234,240,255,.84);
      font-size: 12px;
      line-height: 1;
      margin-left: 8px;
      cursor: help;
      background: rgba(0,0,0,.22);
      box-shadow:
        0 0 14px rgba(60,125,249,.06),
        0 0 12px rgba(88,4,164,.05);
    }

    /* Badges base */
    .badge{
      border: 2px solid rgba(60,125,249,.26);
      background: rgba(0,0,0,.14);
      color: rgba(234,240,255,.95);
      font-weight: 800;
      letter-spacing: .15px;
      text-shadow: 0 0 10px rgba(60,125,249,.06);
    }

    /* Type badges */
    .type-badge{ padding: .40rem .55rem; border-radius: 999px; }
    .type-blue   { border-color: rgba(60,125,249,.60); background: rgba(60,125,249,.10); color: rgba(234,240,255,.98); }
    .type-indigo { border-color: rgba(19,24,243,.55); background: rgba(19,24,243,.10); color: rgba(234,240,255,.98); }
    .type-violet { border-color: rgba(88,4,164,.50);  background: rgba(88,4,164,.10);  color: rgba(234,240,255,.98); }
    .type-lav    { border-color: rgba(207,157,255,.45); background: rgba(207,157,255,.08); color: rgba(234,240,255,.98); }
    .type-neutral{ border-color: rgba(255,255,255,.18); background: rgba(255,255,255,.06); color: rgba(234,240,255,.92); }

    /* Status badges */
    .status-badge{ padding: .40rem .55rem; border-radius: 999px; background: rgba(0,0,0,.12) !important; }
    .status-new{
      border-color: rgba(60,125,249,.70) !important;
      color: rgba(234,240,255,.98) !important;
    }
    .status-ack{
      border-color: rgba(46,242,167,.70) !important;
      color: rgba(234,240,255,.98) !important;
    }
    .status-fp{
      border-color: rgba(255,255,255,.32) !important;
      color: rgba(234,240,255,.92) !important;
    }

    /* Plotly containers */
    #typeChart, #timeChart{
      border-radius: 16px;
      overflow:hidden;
      background: rgba(0,0,0,.10);
      box-shadow:
        0 0 0 1px rgba(60,125,249,.18),
        0 0 18px rgba(60,125,249,.05),
        0 0 14px rgba(88,4,164,.04);
    }

    /* TABLE */
    .table{
      --bs-table-bg: transparent;
      --bs-table-color: rgba(234,240,255,.92);
      --bs-table-border-color: rgba(60,125,249,.14);
      --bs-table-striped-bg: rgba(60,125,249,.015);
      --bs-table-striped-color: rgba(234,240,255,.92);
      --bs-table-hover-bg: rgba(60,125,249,.02);
      --bs-table-hover-color: rgba(234,240,255,.96);

      color: var(--bs-table-color) !important;
      margin:0;
      font-weight: 500;
      background: transparent !important;
    }

    .table thead th{
      font-size: 12px;
      color: rgba(234,240,255,.78) !important;
      text-transform: uppercase;
      letter-spacing: .25px;
      border-bottom: 1px solid rgba(60,125,249,.18) !important;
      background: rgba(0,0,0,.14) !important;
      font-weight: 800;
    }

    .table tbody tr{
      border-top: 1px solid rgba(255,255,255,.04) !important;
      background: transparent !important;
      transition: background .15s ease;
    }

    .table td, .table th{
      padding: 10px 10px !important;
      vertical-align: middle !important;
      background: transparent !important;
    }

    /* Buttons in table */
    .btn-table{
      border-radius: 12px !important;
      padding: 7px 10px !important;
      font-weight: 800 !important;
      letter-spacing: .15px;
      background: transparent !important;
      border-width: 2px !important;
      box-shadow: 0 0 14px rgba(0,0,0,.0);
    }

    .btn-table-success{
      border-color: rgba(46,242,167,.65) !important;
      color: rgba(234,240,255,.95) !important;
    }
    .btn-table-success:hover{
      background: rgba(46,242,167,.08) !important;
    }

    .btn-table-secondary{
      border-color: rgba(255,255,255,.26) !important;
      color: rgba(234,240,255,.92) !important;
    }
    .btn-table-secondary:hover{
      background: rgba(255,255,255,.06) !important;
    }

    .card.card-network{
      overflow: visible !important;
      z-index: 30;
    }
    .card.card-network .dropdown-menu{
      z-index: 2000 !important;
    }

    .card.card-filters{
      overflow: visible !important;
      z-index: 30;
    }
    .card.card-filters .dropdown-menu{
      z-index: 2000 !important;
    }

    @media (max-width: 992px){
      .topbar{ align-items:flex-start; flex-direction:column; }
      .brand h1{ white-space: normal; }
    }

    #netIfaceMenu{
      max-height: 320px;
      overflow-y: auto;
      overflow-x: hidden;
      overscroll-behavior: contain;
    }

    #netIfaceMenu .dropdown-item{
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  </style>
</head>

<body>
  <!-- Neon tubes overlay -->
  <svg class="tube-overlay" viewBox="0 0 1400 900" preserveAspectRatio="none" aria-hidden="true">
    <defs>
      <linearGradient id="tubeA" x1="0" y1="0" x2="1" y2="1">
        <stop offset="0" stop-color="#3C7DF9" stop-opacity="0.55"/>
        <stop offset="0.50" stop-color="#1318F3" stop-opacity="0.42"/>
        <stop offset="1" stop-color="#CF9DFF" stop-opacity="0.18"/>
      </linearGradient>
      <linearGradient id="tubeB" x1="1" y1="0" x2="0" y2="1">
        <stop offset="0" stop-color="#1318F3" stop-opacity="0.48"/>
        <stop offset="0.60" stop-color="#5804A4" stop-opacity="0.34"/>
        <stop offset="1" stop-color="#3C7DF9" stop-opacity="0.18"/>
      </linearGradient>

      <filter id="glowA">
        <feGaussianBlur stdDeviation="4.6" result="b"/>
        <feColorMatrix in="b" type="matrix"
          values="1 0 0 0 0
                  0 1 0 0 0
                  0 0 1 0 0
                  0 0 0 14 -6" result="g"/>
        <feMerge>
          <feMergeNode in="g"/>
          <feMergeNode in="SourceGraphic"/>
        </feMerge>
      </filter>
    </defs>

    <!-- Tubes -->
    <path d="M -120 260 C 120 120, 360 420, 600 280 S 980 220, 1180 360 S 1500 420, 1540 260"
          fill="none" stroke="url(#tubeA)" stroke-width="18" stroke-linecap="round" filter="url(#glowA)"/>
    <path d="M -140 650 C 120 520, 360 760, 620 640 S 980 520, 1180 680 S 1500 760, 1540 600"
          fill="none" stroke="url(#tubeB)" stroke-width="14" stroke-linecap="round" filter="url(#glowA)"/>

    <!-- тонкие контуры -->
    <path d="M -90 240 C 160 110, 360 420, 620 300 S 980 220, 1180 360 S 1500 420, 1520 280"
          fill="none" stroke="rgba(60,125,249,0.14)" stroke-width="2.0"/>
    <path d="M -80 292 C 150 160, 360 440, 610 320 S 980 240, 1180 380 S 1500 440, 1520 310"
          fill="none" stroke="rgba(19,24,243,0.12)" stroke-width="1.6"/>
    <path d="M -110 670 C 140 540, 380 770, 640 660 S 980 520, 1180 680 S 1500 760, 1540 620"
          fill="none" stroke="rgba(88,4,164,0.12)" stroke-width="1.8"/>

    <path d="M 220 -60 C 320 120, 140 240, 300 360 S 520 540, 360 660 S 240 820, 420 980"
          fill="none" stroke="rgba(60,125,249,0.08)" stroke-width="2.0"/>
    <path d="M 1240 -80 C 1120 120, 1320 240, 1140 360 S 940 560, 1120 680 S 1260 820, 1060 980"
          fill="none" stroke="rgba(207,157,255,0.07)" stroke-width="2.0"/>
  </svg>

  <div class="wrap">
    <div class="container">

      <!-- Header -->
      <div class="topbar">
        <div class="brand">
          <div class="logoFrame">
            <img
              class="logo"
              src="logo.png"
              alt="PreVisor logo"
              onerror="this.closest('.logoFrame').style.display='none'"
            />
          </div>

          <div style="min-width:0;">
            <h1 class="mb-0">PreVisor Dashboard</h1>

            <div class="statusline">
              <span class="kpi primary">
                <span class="dot"></span>
                Мониторинг: <span id="monitorState" class="badge">-</span>
              </span>

              <span class="kpi">
                <span class="dot"></span>
                Очередь: <span id="monitorQueue" class="mono">-</span>
              </span>

              <span class="kpi secondary">
                <span class="dot"></span>
                Батч: <span id="monitorBatch" class="mono">-</span>
              </span>

              <span class="kpi tertiary">
                <span class="dot"></span>
                Telegram: <span id="telegramStatus" class="badge">-</span>
              </span>

              <span class="kpi">
                <span class="dot"></span>
                Последнее обновление: <span id="lastRefresh" class="mono">-</span>
              </span>

              <span class="kpi">
                <span class="dot"></span>
                Время: <span id="timeZoneLabel" class="mono">MSK (UTC+3)</span>
              </span>
            </div>
          </div>
        </div>

        <div class="btn-group">
          <button class="btn btn-neon" onclick="startMonitor()">Старт</button>
          <button class="btn btn-ghost" onclick="stopMonitor()">Стоп</button>
          <button class="btn btn-ghost" onclick="loadAlerts()">Обновить</button>
        </div>
      </div>

      <!-- Панель запуска анализа / сбор baseline -->
      <div class="card mb-4 card-network">
        <div class="card-body">
          <div class="row g-3 align-items-end">
            <div class="col-md-5">
              <label class="form-label">Файл для анализа (опционально)</label>
              <input type="file" id="fileInput" class="form-control">
            </div>

            <!-- Режим -->
            <div class="col-md-3">
              <label class="form-label">Режим</label>
              <input type="hidden" id="runMode" value="real">
              <div class="dropdown">
                <button id="runModeBtn" class="btn btn-ghost dropdown-toggle w-100 text-start" data-bs-toggle="dropdown">
                  real
                </button>
                <ul class="dropdown-menu w-100">
                  <li>
                    <a class="dropdown-item d-flex justify-content-between align-items-center" href="#" onclick="setRunMode('real'); return false;">
                      <span>real</span>
                      <span class="mode-help" title="Захват реального трафика с интерфейса, подходит для основного сценария.">?</span>
                    </a>
                  </li>
                  <li>
                    <a class="dropdown-item d-flex justify-content-between align-items-center" href="#" onclick="setRunMode('demo'); return false;">
                      <span>demo</span>
                      <span class="mode-help" title="Демонстрация на sample/симулированных данных (быстро и безопасно).">?</span>
                    </a>
                  </li>
                  <li>
                    <a class="dropdown-item d-flex justify-content-between align-items-center" href="#" onclick="setRunMode('test'); return false;">
                      <span>test</span>
                      <span class="mode-help" title="Внутренний тестовый режим (для проверки пайплайна).">?</span>
                    </a>
                  </li>
                  <li>
                    <a class="dropdown-item d-flex justify-content-between align-items-center" href="#" onclick="setRunMode('dataset'); return false;">
                      <span>dataset</span>
                      <span class="mode-help" title="Запуск по подготовленному processed датасету из data/runtime/datasets.">?</span>
                    </a>
                  </li>
                </ul>
              </div>
            </div>

            <!-- Модель -->
            <div class="col-md-2">
              <label class="form-label">Модель</label>
              <input type="hidden" id="runModel" value="rf">
              <div class="dropdown">
                <button id="runModelBtn" class="btn btn-ghost dropdown-toggle w-100 text-start" data-bs-toggle="dropdown">
                  rf
                </button>
                <ul class="dropdown-menu w-100">
                  <li><a class="dropdown-item" href="#" onclick="setRunModel('rf'); return false;">rf</a></li>
                  <li><a class="dropdown-item" href="#" onclick="setRunModel('xgb'); return false;">xgb</a></li>
                </ul>
              </div>
            </div>

            <div class="col-md-2">
              <button class="btn btn-neon w-100" onclick="runAnalysis()">Разовый анализ</button>
            </div>
          </div>

          <div class="row g-3 align-items-end mt-1">
            <div class="col-md-6">
              <label class="form-label">Сетевой интерфейс</label>

              <input type="hidden" id="netIface" value="">
              <div class="dropdown">
                <button id="netIfaceBtn" class="btn btn-ghost dropdown-toggle w-100 text-start" data-bs-toggle="dropdown">
                  Выберите интерфейс
                </button>
                <ul id="netIfaceMenu" class="dropdown-menu w-100"></ul>
              </div>
            </div>

            <div class="col-md-3">
              <button class="btn btn-ghost w-100" onclick="applyNetIface()">Применить</button>
            </div>

            <div class="col-md-3">
              <button class="btn btn-ghost w-100" onclick="loadInterfaces()">Обновить интерфейсы</button>
            </div>

            <div class="small-muted mt-1" id="netIfaceHint">Текущий интерфейс: —</div>

            <div class="col-md-3">
              <button class="btn btn-ghost w-100" onclick="collectBaseline()">Накопить baseline</button>
            </div>

            <div class="col-md-3">
              <div class="small-muted" id="runResult" style="padding: 10px 0;">Сводка последнего запуска: —</div>
            </div>
          </div>
        </div>
      </div>

      <div class="row">
        <!-- График по типам -->
        <div class="col-md-6">
          <div class="card">
            <div class="card-header">Алерты по типам</div>
            <div class="card-body">
              <div id="typeChart" style="height: 320px;"></div>
            </div>
          </div>
        </div>

        <!-- График по времени -->
        <div class="col-md-6">
          <div class="card">
            <div class="card-header">Динамика алертов</div>
            <div class="card-body">
              <div id="timeChart" style="height: 320px;"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Фильтры -->
      <div class="card mt-4 card-filters">
        <div class="card-body row g-3 align-items-end">

          <div class="col-md-4">
            <label class="form-label">Тип</label>
            <input type="hidden" id="filterType" value="">
            <div class="dropdown">
              <button id="filterTypeBtn" class="btn btn-ghost dropdown-toggle w-100 text-start" data-bs-toggle="dropdown">
                Все типы
              </button>
              <ul id="filterTypeMenu" class="dropdown-menu w-100"></ul>
            </div>
          </div>

          <div class="col-md-4">
            <label class="form-label">Статус</label>
            <input type="hidden" id="filterStatus" value="">
            <div class="dropdown">
              <button id="filterStatusBtn" class="btn btn-ghost dropdown-toggle w-100 text-start" data-bs-toggle="dropdown">
                Все
              </button>
              <ul id="filterStatusMenu" class="dropdown-menu w-100"></ul>
            </div>
          </div>

          <div class="col-md-4">
            <label class="form-label">Мин. риск, %</label>
            <input type="number" id="filterMinProb" class="form-control" value="0" min="0" max="100" step="1" onchange="loadAlerts()">
          </div>

        </div>
      </div>

      <!-- Таблица алертов -->
      <div class="card mt-3">
        <div class="card-header">Последние алерты</div>
        <div class="card-body">
          <div class="table-responsive">
            <table class="table table-sm table-hover align-middle">
              <thead>
                <tr>
                  <th>ID</th>
                  <th>Время</th>
                  <th>Тип</th>
                  <th>Риск</th>
                  <th>IP</th>
                  <th>Статус</th>
                  <th></th>
                </tr>
              </thead>
              <tbody id="alertsTable"></tbody>
            </table>
          </div>
        </div>
      </div>

    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script>
      const TIMEZONE = 'Europe/Moscow';
      const TIMEZONE_LABEL = 'MSK (UTC+3)';

      const FORMAT_FULL = new Intl.DateTimeFormat('ru-RU', {
        timeZone: TIMEZONE,
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      });

      const TIME_ONLY = new Intl.DateTimeFormat('ru-RU', {
        timeZone: TIMEZONE,
        hour: '2-digit',
        minute: '2-digit'
      });

      const TIME_HOVER = new Intl.DateTimeFormat('ru-RU', {
        timeZone: TIMEZONE,
        day: '2-digit',
        month: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });

      // Для генерации суточного паттерна именно в MSK
      const HM_FMT = new Intl.DateTimeFormat('en-GB', {
        timeZone: TIMEZONE,
        hour: '2-digit',
        minute: '2-digit',
        hour12: false
      });

      function hourFloatTZ(date) {
        const parts = HM_FMT.formatToParts(date);
        const hh = Number(parts.find(p => p.type === 'hour')?.value ?? 0);
        const mm = Number(parts.find(p => p.type === 'minute')?.value ?? 0);
        return hh + (mm / 60);
      }

      const ALERT_DESCRIPTIONS = {
        'Suspicious Port': 'Повторяющиеся обращения к типичным «рискованным» портам.',
        'Port Scanning': 'Много уникальных портов от одного источника за короткий интервал.',
        'DDoS': 'Всплеск пакетов от множества источников к одной цели.',
        'HTTP Anomaly': 'Подозрительные HTTP-паттерны (инъекции, traversal, и т.п.).',
        'Anomaly': 'Нетипичное поведение трафика относительно привычного baseline (возможная новая/редкая угроза или сбой).'
      };

      // --- deterministic pseudo-random (so mock looks stable) ---
      function mulberry32(seed) {
        return function() {
          let t = seed += 0x6D2B79F5;
          t = Math.imul(t ^ (t >>> 15), t | 1);
          t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      }
      const rnd = mulberry32(1337);

      // --- mock state ---
      const MOCK = {
        monitor: {
          running: true,
          queue_size: 0,
          batch_size: 200,
          flush_sec: 5,
          iface: 'Беспроводная сеть'
        },
        telegram: {
          enabled: true,
          ready: true
        },
        interfaces: [
          { name: 'Беспроводная сеть', description: 'Intel(R) Wi-Fi 6 AX200 160MHz', ips: ['192.168.1.114'] },
          { name: 'Ethernet', description: 'Realtek PCIe GBE Family Controller', ips: ['192.168.1.22'] },
          { name: 'VPN', description: 'WireGuard Tunnel', ips: ['10.0.0.2'] },
          { name: 'Loopback', description: 'Software Loopback', ips: ['127.0.0.1'] }
        ],
        alerts: []
      };

      function escapeAttr(value) {
        return String(value || '')
          .replace(/&/g, '&amp;')
          .replace(/\"/g, '&quot;');
      }

      function parseTs(ts) {
        if (!ts) return null;
        let raw = ts;
        if (typeof raw === 'string' && !raw.match(/[zZ]|[+-]\d{2}:\d{2}$/)) raw = raw + 'Z';
        const d = new Date(raw);
        if (isNaN(d.getTime())) return null;
        return d;
      }

      function fmtTs(ts) {
        const d = parseTs(ts);
        if (!d) return '—';
        return FORMAT_FULL.format(d);
      }

      function fmtNow() {
        return FORMAT_FULL.format(new Date());
      }

      function clamp01(x) { return Math.max(0, Math.min(1, x)); }

      function pickWeighted(options) {
        const sum = options.reduce((s, o) => s + o.w, 0);
        let r = rnd() * sum;
        for (const o of options) {
          r -= o.w;
          if (r <= 0) return o.v;
        }
        return options[options.length - 1].v;
      }

      function randomIp() {
        const a = 10 + Math.floor(rnd() * 180);
        const b = Math.floor(rnd() * 256);
        const c = Math.floor(rnd() * 256);
        const d = 1 + Math.floor(rnd() * 254);
        return `${a}.${b}.${c}.${d}`;
      }

      function gauss(x, mu, sigma) {
        const z = (x - mu) / sigma;
        return Math.exp(-0.5 * z * z);
      }

      function seedMockAlerts() {
        // 5 типов, без придуманных
        const types = [
          { v: 'Port Scanning', w: 22 },
          { v: 'Suspicious Port', w: 21 },
          { v: 'HTTP Anomaly', w: 20 },
          { v: 'DDoS', w: 18 },
          { v: 'Anomaly', w: 19 }
        ];

        const statusW = [
          { v: 'new', w: 62 },
          { v: 'acknowledged', w: 26 },
          { v: 'false_positive', w: 12 }
        ];

        const now = new Date();
        const windowHours = 24;
        const binMinutes = 30;

        const start = new Date(now.getTime() - windowHours * 60 * 60 * 1000);
        const binMs = binMinutes * 60 * 1000;
        const binCount = Math.floor((now - start) / binMs) + 1;

        const alerts = [];
        let idSeq = 1200;

        for (let i = 0; i < binCount; i += 1) {
          const binStart = new Date(start.getTime() + i * binMs);
          const h = hourFloatTZ(binStart);

          // 2 “дневных” пика + небольшой фон, + шум
          let lam = 0.25
            + 1.35 * gauss(h, 11.5, 3.0)
            + 1.15 * gauss(h, 18.5, 3.2);

          lam += (rnd() - 0.5) * 0.30;

          // редкие всплески
          if (rnd() < 0.06) lam += 4 + Math.floor(rnd() * 4);

          const count = Math.max(0, Math.round(lam));

          for (let j = 0; j < count; j += 1) {
            const t = new Date(binStart.getTime() + rnd() * binMs);
            const type = pickWeighted(types);
            const status = pickWeighted(statusW);

            let base = 0.30 + rnd() * 0.55;
            if (type === 'DDoS') base = 0.70 + rnd() * 0.25;
            if (type === 'Port Scanning') base = 0.55 + rnd() * 0.35;
            if (status === 'false_positive') base = 0.18 + rnd() * 0.25;

            alerts.push({
              id: idSeq++,
              timestamp: t.toISOString(),
              type,
              probability: clamp01(base),
              source_ip: randomIp(),
              status
            });
          }
        }

        alerts.sort((a, b) => (b.timestamp > a.timestamp ? 1 : -1));
        MOCK.alerts = alerts;
      }

      // ---------- UI mappings ----------
      function typeBadgeClass(type) {
        const t = String(type || '').toLowerCase();
        if (t.includes('ddos')) return 'type-indigo';
        if (t.includes('scan')) return 'type-blue';
        if (t.includes('http')) return 'type-violet';
        if (t.includes('anomaly')) return 'type-lav';
        if (t.includes('suspicious')) return 'type-blue';
        return 'type-neutral';
      }

      function statusBadgeClass(status) {
        const s = String(status || '').toLowerCase();
        if (s === 'acknowledged') return 'status-ack';
        if (s === 'false_positive') return 'status-fp';
        return 'status-new';
      }

      // ---------- Dropdown helpers ----------
      function setButtonText(btnId, text) {
        const btn = document.getElementById(btnId);
        if (btn) btn.textContent = text;
      }

      function setRunMode(mode) {
        const input = document.getElementById('runMode');
        if (input) input.value = mode;
        setButtonText('runModeBtn', mode);
      }

      function setRunModel(model) {
        const input = document.getElementById('runModel');
        if (input) input.value = model;
        setButtonText('runModelBtn', model);
      }

      function setFilterType(type) {
        const input = document.getElementById('filterType');
        if (input) input.value = type || '';
        setButtonText('filterTypeBtn', type ? type : 'Все типы');
        loadAlerts();
      }

      function setFilterStatus(status) {
        const input = document.getElementById('filterStatus');
        if (input) input.value = status || '';
        const label = status ? status : 'Все';
        setButtonText('filterStatusBtn', label);
        loadAlerts();
      }

      const IFACE_LABELS = {};
      function setNetIface(value, label) {
        const input = document.getElementById('netIface');
        if (input) input.value = value || '';
        setButtonText('netIfaceBtn', label || value || 'Выберите интерфейс');
      }

      function initStatusDropdown() {
        const menu = document.getElementById('filterStatusMenu');
        if (!menu) return;

        menu.innerHTML = `
          <li><a class="dropdown-item" href="#" onclick="setFilterStatus(''); return false;">Все</a></li>
          <li><a class="dropdown-item" href="#" onclick="setFilterStatus('new'); return false;">new</a></li>
          <li><a class="dropdown-item" href="#" onclick="setFilterStatus('acknowledged'); return false;">acknowledged</a></li>
          <li><a class="dropdown-item" href="#" onclick="setFilterStatus('false_positive'); return false;">false_positive</a></li>
        `;
      }

      // ---------- Plotly ----------
      function plotlyBaseLayout() {
        const grid = 'rgba(60,125,249,0.10)';
        const axis = 'rgba(234,240,255,0.80)';
        const title = 'rgba(234,240,255,0.95)';
        return {
          paper_bgcolor: 'rgba(0,0,0,0)',
          plot_bgcolor: 'rgba(0,0,0,0)',
          font: { color: axis, family: 'Montserrat, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif' },
          margin: { t: 40, l: 40, r: 10, b: 60 },
          xaxis: {
            gridcolor: grid,
            zerolinecolor: 'rgba(19,24,243,0.12)',
            tickfont: { color: axis },
            titlefont: { color: axis }
          },
          yaxis: {
            gridcolor: grid,
            zerolinecolor: 'rgba(19,24,243,0.12)',
            tickfont: { color: axis },
            titlefont: { color: axis },
            rangemode: 'tozero'
          },
          title: { font: { color: title, size: 14 } }
        };
      }

      // ---------- MOCK actions ----------
      function refreshTelegramStatus() {
        const badge = document.getElementById('telegramStatus');
        if (!badge) return;

        if (!MOCK.telegram.enabled) {
          badge.textContent = 'OFF';
          badge.style.borderColor = 'rgba(255,255,255,.22)';
          return;
        }

        if (MOCK.telegram.ready) {
          badge.textContent = 'ON';
          badge.style.borderColor = 'rgba(46,242,167,.70)';
          return;
        }

        badge.textContent = 'NOT CONFIG';
        badge.style.borderColor = 'rgba(255,204,102,.55)';
      }

      function refreshMonitorStatus() {
        const badge = document.getElementById('monitorState');
        const queue = document.getElementById('monitorQueue');
        const batch = document.getElementById('monitorBatch');
        const ifaceHint = document.getElementById('netIfaceHint');

        if (badge) {
          badge.textContent = MOCK.monitor.running ? 'ON' : 'OFF';
          badge.style.borderColor = MOCK.monitor.running ? 'rgba(46,242,167,.70)' : 'rgba(255,255,255,.22)';
        }
        if (queue) queue.textContent = MOCK.monitor.queue_size ?? '-';

        if (batch) {
          const batchSize = (MOCK.monitor.batch_size ?? '-');
          const flushSec = (MOCK.monitor.flush_sec ?? '-');
          batch.textContent = `${batchSize} / ${flushSec}s`;
        }

        if (ifaceHint) ifaceHint.textContent = `Текущий интерфейс: ${MOCK.monitor.iface || '-'}`;

        if (MOCK.monitor.iface) {
          const label = IFACE_LABELS[MOCK.monitor.iface] || MOCK.monitor.iface;
          setNetIface(MOCK.monitor.iface, label);
        }
      }

      function startMonitor() {
        MOCK.monitor.running = true;
        MOCK.monitor.queue_size = 8 + Math.floor(rnd() * 12);
        refreshMonitorStatus();
      }

      function stopMonitor() {
        MOCK.monitor.running = false;
        MOCK.monitor.queue_size = 0;
        refreshMonitorStatus();
      }

      function loadInterfaces() {
        const menu = document.getElementById('netIfaceMenu');
        if (!menu) return;

        const opts = MOCK.interfaces.map(item => {
          const value = item.name || item.description || 'unknown';
          const label = item.name || value; // только name
          return { value, label };
        });

        for (const o of opts) IFACE_LABELS[o.value] = o.label;

        menu.innerHTML = opts.map(o =>
          `<li><a class="dropdown-item" href="#" onclick="setNetIface('${escapeAttr(o.value)}','${escapeAttr(o.label)}'); return false;">${o.label}</a></li>`
        ).join('');

        if (!document.getElementById('netIface')?.value) {
          setNetIface(MOCK.monitor.iface, IFACE_LABELS[MOCK.monitor.iface] || MOCK.monitor.iface);
        }
      }

      function applyNetIface() {
        const iface = document.getElementById('netIface')?.value || '';
        if (!iface) {
          alert('Выберите интерфейс.');
          return;
        }
        MOCK.monitor.iface = iface;
        refreshMonitorStatus();
      }

      function updateStatus(alertId, newStatus) {
        const idx = MOCK.alerts.findIndex(a => Number(a.id) === Number(alertId));
        if (idx === -1) return;
        MOCK.alerts[idx].status = newStatus;
        loadAlerts();
      }

      function runAnalysis() {
        const mode = document.getElementById('runMode')?.value || 'real';
        const model = document.getElementById('runModel')?.value || 'rf';

        const newAlerts = 4 + Math.floor(rnd() * 4);
        const now = Date.now();

        for (let i = 0; i < newAlerts; i += 1) {
          const t = now - i * (4 + Math.floor(rnd() * 9)) * 60 * 1000;
          const type = pickWeighted([
            { v: 'Port Scanning', w: 22 },
            { v: 'Suspicious Port', w: 21 },
            { v: 'HTTP Anomaly', w: 20 },
            { v: 'DDoS', w: 18 },
            { v: 'Anomaly', w: 19 }
          ]);

          MOCK.alerts.unshift({
            id: 9000 + Math.floor(rnd() * 9000),
            timestamp: new Date(t).toISOString(),
            type,
            probability: clamp01(0.35 + rnd() * 0.60),
            source_ip: randomIp(),
            status: 'new'
          });
        }

        MOCK.alerts.sort((a, b) => (b.timestamp > a.timestamp ? 1 : -1));

        const total = MOCK.alerts.length;
        document.getElementById('runResult').textContent =
          `mode=${mode}, model=${model}, new_alerts=${newAlerts}, total_alerts=${total}, telegram_sent=${MOCK.telegram.ready ? newAlerts : 0}`;

        loadAlerts();
      }

      function collectBaseline() {
        const captured = 200;
        const saved = 200;
        const pool = 4200 + Math.floor(rnd() * 600);
        const retrained = rnd() > 0.35;

        document.getElementById('runResult').textContent =
          `Baseline (traffic_logs): captured_rows=${captured}, saved_rows=${saved}, baseline_pool_rows=${pool}, anomaly_retrained=${retrained}, csv=baseline_${new Date().toISOString().slice(0,10)}.csv`;
      }

      // ---------- Render ----------
      function loadAlerts() {
        const type = (document.getElementById('filterType')?.value) || '';
        const status = (document.getElementById('filterStatus')?.value) || '';
        const minProb = Number(document.getElementById('filterMinProb')?.value || 0) / 100;

        let alerts = [...MOCK.alerts];

        if (type) alerts = alerts.filter(a => a.type === type);
        if (status) alerts = alerts.filter(a => a.status === status);

        if (!isNaN(minProb) && minProb > 0) {
          alerts = alerts.filter(a => Number(a.probability || 0) >= minProb);
        }

        const TABLE_LIMIT = 18;
        const rows = alerts.slice(0, TABLE_LIMIT);

        const tbody = document.getElementById('alertsTable');
        tbody.innerHTML = rows.map(a => `
          <tr>
            <td class="mono">${a.id}</td>
            <td class="mono">${fmtTs(a.timestamp)}</td>
            <td>
              <span class="badge type-badge ${typeBadgeClass(a.type)}"
                title="${escapeAttr(ALERT_DESCRIPTIONS[a.type] || 'Описание недоступно')}">
                ${a.type}
              </span>
            </td>
            <td class="mono">${(Number(a.probability || 0) * 100).toFixed(1)}%</td>
            <td class="mono">${a.source_ip || '-'}</td>
            <td>
              <span class="badge status-badge ${statusBadgeClass(a.status)}">${a.status}</span>
            </td>
            <td>
              <div class="btn-group btn-group-sm" role="group">
                <button class="btn btn-table btn-table-success" onclick="updateStatus(${a.id}, 'acknowledged')">ACK</button>
                <button class="btn btn-table btn-table-secondary" onclick="updateStatus(${a.id}, 'false_positive')">False Positive</button>
              </div>
            </td>
          </tr>
        `).join('');

        updateCharts(alerts);
        updateFilterTypeDropdown(MOCK.alerts);

        refreshMonitorStatus();
        refreshTelegramStatus();

        const last = document.getElementById('lastRefresh');
        if (last) last.textContent = fmtNow();
      }

      function updateCharts(alerts) {
        // --- by type ---
        const byType = {};
        alerts.forEach(a => {
          const t = a.type || 'Unknown';
          byType[t] = (byType[t] || 0) + 1;
        });

        // сортировка по убыванию
        const typeEntries = Object.entries(byType).sort((a, b) => b[1] - a[1]);
        const typeLabels = typeEntries.map(entry => entry[0]);
        const typeCounts = typeEntries.map(entry => entry[1]);
        const typeDescs = typeEntries.map(entry => ALERT_DESCRIPTIONS[entry[0]] || 'Описание недоступно');

        const base1 = plotlyBaseLayout();
        Plotly.newPlot('typeChart', [{
          x: typeLabels,
          y: typeCounts,
          type: 'bar',
          marker: {
            color: 'rgba(60,125,249,0.70)',
            line: { color: 'rgba(19,24,243,0.85)', width: 1.4 }
          },
          customdata: typeDescs,
          hovertemplate: '%{x}<br>%{customdata}<br>Alerts: %{y}<extra></extra>'
        }], {
          ...base1,
          title: { text: 'Количество алертов по типам', font: { color: 'rgba(234,240,255,0.95)', size: 14 } }
        }, { displayModeBar: false, responsive: true });

        // --- time (24h, 30min bins), show only time labels but keep unique x via ISO ---
        const now = new Date();
        const windowHours = 24;
        const binMinutes = 30;

        const start = new Date(now.getTime() - windowHours * 60 * 60 * 1000);
        const binMs = binMinutes * 60 * 1000;
        const binCount = Math.floor((now - start) / binMs) + 1;

        const xISO = [];
        const xTimeText = [];
        const xHoverText = [];
        const counts = new Array(binCount).fill(0);

        for (let i = 0; i < binCount; i += 1) {
          const d = new Date(start.getTime() + i * binMs);
          xISO.push(d.toISOString());
          xTimeText.push(TIME_ONLY.format(d));
          xHoverText.push(TIME_HOVER.format(d));
        }

        alerts.forEach(a => {
          const d = parseTs(a.timestamp);
          if (!d) return;
          if (d < start || d > now) return;
          const idx = Math.floor((d - start) / binMs);
          if (idx >= 0 && idx < counts.length) counts[idx] += 1;
        });

        // ticks: every 2 hours (step=4 for 30min bins)
        const step = 4;
        const tickvals = xISO.filter((_, i) => i % step === 0);
        const ticktext = xTimeText.filter((_, i) => i % step === 0);

        const base2 = plotlyBaseLayout();
        Plotly.newPlot('timeChart', [{
          x: xISO,
          y: counts,
          type: 'scatter',
          mode: 'lines+markers',
          line: {
            color: 'rgba(19,24,243,0.92)',
            width: 3.0,
            shape: 'spline',
            smoothing: 1.15
          },
          fill: 'tozeroy',
          fillcolor: 'rgba(88,4,164,0.08)',
          marker: {
            size: 5,
            color: 'rgba(60,125,249,0.92)',
            line: { color: 'rgba(207,157,255,0.45)', width: 1 }
          },
          customdata: xHoverText,
          hovertemplate: '%{customdata}<br>Alerts: %{y}<extra></extra>'
        }], {
          ...base2,
          title: { text: 'Динамика алертов за сутки', font: { color: 'rgba(234,240,255,0.95)', size: 14 } },
          xaxis: {
            ...base2.xaxis,
            type: 'category',
            tickmode: 'array',
            tickvals: tickvals,
            ticktext: ticktext,
            title: { text: 'Время (MSK)', font: { color: 'rgba(234,240,255,0.78)' } }
          },
          yaxis: { ...base2.yaxis, title: { text: 'Количество', font: { color: 'rgba(234,240,255,0.78)' } } }
        }, { displayModeBar: false, responsive: true });
      }

      function updateFilterTypeDropdown(allAlerts) {
        const types = [...new Set(allAlerts.map(a => a.type))].filter(Boolean).sort();
        const menu = document.getElementById('filterTypeMenu');
        const current = document.getElementById('filterType')?.value || '';

        if (!menu) return;

        let html = `<li><a class="dropdown-item" href="#" onclick="setFilterType(''); return false;">Все типы</a></li>`;
        html += types.map(t => `<li><a class="dropdown-item" href="#" onclick="setFilterType('${escapeAttr(t)}'); return false;">${t}</a></li>`).join('');
        menu.innerHTML = html;

        if (current && !types.includes(current)) {
          setFilterType('');
        } else {
          setButtonText('filterTypeBtn', current ? current : 'Все типы');
        }
      }

      // ---------- init ----------
      document.getElementById('timeZoneLabel').textContent = TIMEZONE_LABEL;

      initStatusDropdown();
      setRunMode('real');
      setRunModel('rf');
      setFilterType('');
      setFilterStatus('');

      seedMockAlerts();
      loadInterfaces();

      refreshTelegramStatus();
      refreshMonitorStatus();

      loadAlerts();

      setInterval(() => {
        if (MOCK.monitor.running) {
          const drift = (rnd() > 0.5 ? 1 : -1) * (rnd() > 0.7 ? 2 : 1);
          MOCK.monitor.queue_size = Math.max(0, (MOCK.monitor.queue_size || 0) + drift);
        }
        loadAlerts();
      }, 30000);
  </script>
</body>
</html>
